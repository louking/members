"""add memberdates table

Revision ID: db3ffeebcb11
Revises: b32adff5fe85
Create Date: 2023-12-05 13:53:06.890649

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'db3ffeebcb11'
down_revision = 'b32adff5fe85'
branch_labels = None
depends_on = None


def upgrade(engine_name):
    globals()["upgrade_%s" % engine_name]()


def downgrade(engine_name):
    globals()["downgrade_%s" % engine_name]()





def upgrade_():
    # ### commands auto generated by Alembic - please adjust! ###
    memberdates = op.create_table('memberdates',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('interest_id', sa.Integer(), nullable=True),
    sa.Column('member_id', sa.Integer(), nullable=True),
    sa.Column('start_date', sa.Date(), nullable=True),
    sa.Column('end_date', sa.Date(), nullable=True),
    sa.Column('version_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['interest_id'], ['localinterest.id'], ),
    sa.ForeignKeyConstraint(['member_id'], ['member.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.add_column('membership', sa.Column('memberdates_id', sa.Integer(), nullable=True))
    op.create_foreign_key('membership_ibfk_3', 'membership', 'memberdates', ['memberdates_id'], ['id'])
    # ### end Alembic commands ###

    from sqlalchemy.sql import table, column, select, insert, delete, update
    from alembic import context
    member = table('member',
        column('id', sa.Integer),
        column('interest_id', sa.Integer),
        column('start_date', sa.Date),
        column('end_date', sa.Date),
        column('family_name', sa.String),
        column('given_name', sa.String),
        column('middle_name', sa.String),
        column('gender', sa.String),
        column('dob', sa.Date),
    )
    membership = table('membership',
        column('id', sa.Integer),
        column('member_id', sa.Integer),
        column('memberdates_id', sa.Integer),
    )
    
    # the members table prior to this conversion may have multiple member
    # records for each real member (name, dob)

    # we merge these to the latest member record, creating the appropriate
    # memberdates records, discarding older member records

    # we update the associated membership record(s) for each member record to
    # point to the new memberdates record
    
    # we update the associated membership record(s) for each discarded member
    # record to point to the retained member record
    
    ## set up connection https://stackoverflow.com/a/18739259
    conn = op.get_bind()

    ## get all the members
    stmt = (
        select(member)
        # group the same member together, ordered by end_date with most recent first
        .order_by(member.c.interest_id,
                  member.c.family_name, member.c.given_name, member.c.middle_name, member.c.gender, member.c.dob, 
                  member.c.end_date.desc())
    )
    members = conn.execute(stmt).all()

    ## for member compare
    def get_memberdob(member):
        middlename = f"{member['middle_name']} " if member["middle_name"] else ''
        return f"{member['interest_id']}: {member['family_name']}, {member['given_name']} {middlename}({member['dob']})"

    ## column names for dict(zip())
    mcnames = [c.name for c in member.columns]

    ## do the data migration in a transaction to facilitate downgrade if exceptions (https://stackoverflow.com/a/47057604)
    with context.begin_transaction():

        ## look through all the members
        imembers = iter(members)
        try:
            mtuple = next(imembers)
            m = dict(zip(mcnames, mtuple))
            while True:
                # at top of loop this is the record has the latest end_date for this member
                # save member.id
                m_id = m['id']
                m_interest_id = m['interest_id']
                md = conn.execute(
                    insert(memberdates).
                    values(interest_id=m_interest_id, member_id=m_id, start_date=m['start_date'], end_date=m['end_date'])                
                )
                # https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
                md_id = md.inserted_primary_key[0]
                
                ## update all memberships which pointed to this member to also point to this memberdates
                # update all memberships which point to mnext.id to point to m_id (the most current)
                conn.execute(
                    update(membership).
                    where(membership.c.member_id==m_id).
                    values(memberdates_id=md_id)
                )
                
                # mnext record would have an earlier end_date than m, due to sorted query above
                mnexttuple = next(imembers)
                mnext = dict(zip(mcnames, mnexttuple))
                
                # scan member records which are the same interest/member; 
                #   add memberdates record
                #   update associated membership record(s)
                #   delete
                while get_memberdob(mnext) == get_memberdob(m):
                    md = conn.execute(
                        insert(memberdates).
                        values(interest_id=m_interest_id, member_id=m_id, start_date=mnext['start_date'], end_date=mnext['end_date'])                
                    )
                    md_id = md.inserted_primary_key[0]
                    
                    # update all memberships which point to mnext.id to point to m_id (the most current), new md_id
                    conn.execute(
                        update(membership).
                        where(membership.c.member_id==mnext['id']).
                        values(member_id=m_id, memberdates_id=md_id)
                    )
                    
                    # remove mnext
                    conn.execute(
                        delete(member).
                        where(member.c.id==mnext['id'])
                    )
                    
                    # next inner loop
                    mnexttuple = next(imembers)
                    mnext = dict(zip(mcnames, mnexttuple))
                
                # be ready to start main loop
                m = mnext
                
        except StopIteration:
            pass
            

def downgrade_():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint('membership_ibfk_3', 'membership', type_='foreignkey')
    op.drop_column('membership', 'memberdates_id')
    op.drop_table('memberdates')
    # ### end Alembic commands ###


def upgrade_users():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade_users():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###

